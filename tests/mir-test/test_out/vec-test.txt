error: expected '\n' | ';' but got 'if'
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:62:14
   |
62 |         loop if i == self.len => break
   |              ^^ token located here
   |
   = info: grouped items -> list -> item -> impl -> list -> impl item -> function definition -> function body -> list

error: expected Ident | '\' | 'return' | Int | Char | Bool | 'match' | 'if' | 'let' | Operator but got 'else'
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:63:9
   |
63 |         else {
   |         ^^^^ token located here
   |
   = info: grouped items -> list -> item -> impl -> list -> impl item -> function definition -> function body -> list -> expr -> unit expr

error: function not found
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:37:15
   |
37 |         *self.get(self.len - 1) = val
   |               ^^^ this does not exist
   |
   = info: queried 'struct1\get'

error: variable or enum not found
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:62:9
   |
62 |         loop if i == self.len => break
   |         ^^^^ this does not exist
   |
   = info: queried 'loop'

error: function not found
  --> vec-test\root.ctl:13:8
   |
13 |     vv.get_mut(0).push(3)
   |        ^^^^^^^ this does not exist
   |
   = info: queried 'struct1\get_mut'

info: mir repr of functions:
 fn [] write(var0: ^mut param0, var1: param0) -> ()  { ret var0
    block0(var2: ^mut param0, var3: param0) {
        access var2
        var4 = *var2
        var4 = access var3
        return var0
    }

}

fn [] read(var0: ^param0) -> param0  { ret var3
    block0(var2: ^param0) {
        access var2
        var3 = *var2
        return var3
    }

}

fn [] new() -> 0\Vec[param0]  { ret var2
    block0() {
        var2 ={var3, var4, var5}
        var6 = 0
        var3 = cast[uint, ^mut param0](val6)
        var4 = 0
        var5 = 0
        return var2
    }

}

fn [] with_capacity(var0: uint) -> 0\Vec[param0]  { ret var3
    block0(var2: uint) {
        var3 ={var4, var5, var6}
        access var2
        var9 = sizeof[param0]()
        var8 = uint * uint(val2, val9)
        var7 = malloc(val8)
        var4 = cast[^mut (), ^mut param0](val7)
        var5 = 0
        var6 = access var2
        return var3
    }

}

fn [] push(var0: ^mut 0\Vec[param0], var1: param0) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0], var3: param0) {
        access var2
        var6 = *var2
        var5 = var6.1
        access var2
        var8 = *var2
        var7 = var8.2
        var4 = uint == uint(val5, val7)
        split var4 block1 block2
    }

    block1() {
        access var2
        var1 = grow[param0](val2)
        goto block3 with var1
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var2
        var10 = *var2
        var9 = var10.1
        access var2
        var12 = *var2
        var11 = var12.1
        var13 = 1
        var9 = uint + uint(val11, val13)
        drop var3
        return var0
    }

}

fn [] grow(var0: ^mut 0\Vec[param0]) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0]) {
        access var2
        var6 = *var2
        var5 = var6.2
        var7 = 0
        var4 = uint == uint(val5, val7)
        split var4 block1 block2
    }

    block1() {
        var3 = 1
        goto block3 with var3
    }

    block2() {
        access var2
        var9 = *var2
        var8 = var9.2
        var10 = 2
        var3 = uint * uint(val8, val10)
        goto block3 with var3
    }

    block3(var3: uint) {
        var11 = var3
        access var11
        var14 = sizeof[param0]()
        var13 = uint * uint(val11, val14)
        var12 = malloc(val13)
        var15 = var12
        access var15
        access var2
        var18 = *var2
        var17 = var18.0
        var16 = cast[^mut param0, ^()](val17)
        access var2
        var21 = *var2
        var20 = var21.1
        var22 = sizeof[param0]()
        var19 = uint * uint(val20, val22)
        var0 = memcpy(val15, val16, val19)
        access var2
        var25 = *var2
        var24 = var25.0
        var23 = cast[^mut param0, ^()](val24)
        var0 = free(val23)
        access var2
        var27 = *var2
        var26 = var27.0
        access var15
        var26 = cast[^mut (), ^mut param0](val15)
        return var0
    }

}

fn [] get_ptr(var0: ^0\Vec[param0], var1: uint) -> ^param0  { ret var4
    block0(var2: ^0\Vec[param0], var3: uint) {
        access var2
        var8 = *var2
        var7 = var8.0
        var6 = cast[^mut param0, uint](val7)
        access var3
        var10 = sizeof[param0]()
        var9 = uint * uint(val3, val10)
        var5 = uint + uint(val6, val9)
        var4 = cast[uint, ^param0](val5)
        return var4
    }

}

fn [] get_mut_ptr(var0: ^mut 0\Vec[param0], var1: uint) -> ^mut param0  { ret var4
    block0(var2: ^mut 0\Vec[param0], var3: uint) {
        access var2
        var8 = *var2
        var7 = var8.0
        var6 = cast[^mut param0, uint](val7)
        access var3
        var10 = sizeof[param0]()
        var9 = uint * uint(val3, val10)
        var5 = uint + uint(val6, val9)
        var4 = cast[uint, ^mut param0](val5)
        return var4
    }

}

fn [] drop(var0: ^mut 0\Vec[param0]) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0]) {
        var3 = 0
        var4 = var3
        access var2
        var7 = *var2
        var6 = var7.0
        var5 = cast[^mut param0, ^()](val6)
        var0 = free(val5)
        return var0
    }

}

fn [] main() -> uint  { ret var2
    block0() {
        var3 = new[uint]()
        var4 = var3
        access var4
        var5 = &var4
        var6 = 0
        var0 = push[uint](val5, val6)
        access var4
        var7 = &var4
        var8 = 1
        var0 = push[uint](val7, val8)
        access var4
        var9 = &var4
        var10 = 2
        var0 = push[uint](val9, val10)
        var11 = new[0\Vec[uint]]()
        var12 = var11
        access var12
        var13 = &var12
        access var4
        var0 = push[0\Vec[uint]](val13, val4)
        var2 = 0
        drop var12
        return var2
    }

}



