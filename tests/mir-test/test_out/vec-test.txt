error: scope item not found
  --> vec-test\root.ctl:13:8
   |
13 |     vv.get_mut(0).push(3)
   |        ^^^^^^^ this does not exist or is not imported
   |
   = help: expected method
   = info: debug: queried 'struct1\get_mut'

info: mir repr of functions:
fn [] write(var0: ^mut param0, var1: param0) -> ()  { ret var0
    block0(var2: ^mut param0, var3: param0) {
        access var2
        var4 = *var2
        var4 = access var3
        return var0
    }

}

fn [] read(var0: ^param0) -> param0  { ret var3
    block0(var2: ^param0) {
        access var2
        var3 = *var2
        return var3
    }

}

fn [] new() -> 0\Vec[param0]  { ret var2
    block0() {
        var2 ={var3, var4, var5}
        var6 = 0
        var3 = cast[uint, ^mut param0](val6)
        var4 = 0
        var5 = 0
        return var2
    }

}

fn [] with_capacity(var0: uint) -> 0\Vec[param0]  { ret var3
    block0(var2: uint) {
        var3 ={var4, var5, var6}
        access var2
        var9 = sizeof[param0]()
        var8 = uint * uint(val2, val9)
        var7 = malloc(val8)
        var4 = cast[^mut (), ^mut param0](val7)
        var5 = 0
        var6 = access var2
        return var3
    }

}

fn [] push(var0: ^mut 0\Vec[param0], var1: param0) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0], var3: param0) {
        access var2
        var6 = *var2
        var5 = var6.1
        access var2
        var8 = *var2
        var7 = var8.2
        var4 = uint == uint(val5, val7)
        split var4 block1 block2
    }

    block1() {
        access var2
        var1 = grow[param0](val2)
        goto block3 with var1
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var2
        access var2
        var11 = *var2
        var10 = var11.1
        var9 = get_mut_ptr[param0](val2, val10)
        access var3
        var0 = write[param0](val9, val3)
        access var2
        var13 = *var2
        var12 = var13.1
        access var2
        var15 = *var2
        var14 = var15.1
        var16 = 1
        var12 = uint + uint(val14, val16)
        return var0
    }

}

fn [] grow(var0: ^mut 0\Vec[param0]) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0]) {
        access var2
        var6 = *var2
        var5 = var6.2
        var7 = 0
        var4 = uint == uint(val5, val7)
        split var4 block1 block2
    }

    block1() {
        var3 = 1
        goto block3 with var3
    }

    block2() {
        access var2
        var9 = *var2
        var8 = var9.2
        var10 = 2
        var3 = uint * uint(val8, val10)
        goto block3 with var3
    }

    block3(var3: uint) {
        var11 = var3
        access var11
        var14 = sizeof[param0]()
        var13 = uint * uint(val11, val14)
        var12 = malloc(val13)
        var15 = var12
        access var15
        access var2
        var18 = *var2
        var17 = var18.0
        var16 = cast[^mut param0, ^()](val17)
        access var2
        var21 = *var2
        var20 = var21.1
        var22 = sizeof[param0]()
        var19 = uint * uint(val20, val22)
        var0 = memcpy(val15, val16, val19)
        access var2
        var25 = *var2
        var24 = var25.0
        var23 = cast[^mut param0, ^()](val24)
        var0 = free(val23)
        access var2
        var27 = *var2
        var26 = var27.0
        access var15
        var26 = cast[^mut (), ^mut param0](val15)
        return var0
    }

}

fn [] get_ptr(var0: ^0\Vec[param0], var1: uint) -> ^param0  { ret var4
    block0(var2: ^0\Vec[param0], var3: uint) {
        access var2
        var8 = *var2
        var7 = var8.0
        var6 = cast[^mut param0, uint](val7)
        access var3
        var10 = sizeof[param0]()
        var9 = uint * uint(val3, val10)
        var5 = uint + uint(val6, val9)
        var4 = cast[uint, ^param0](val5)
        return var4
    }

}

fn [] get_mut_ptr(var0: ^mut 0\Vec[param0], var1: uint) -> ^mut param0  { ret var4
    block0(var2: ^mut 0\Vec[param0], var3: uint) {
        access var2
        var8 = *var2
        var7 = var8.0
        var6 = cast[^mut param0, uint](val7)
        access var3
        var10 = sizeof[param0]()
        var9 = uint * uint(val3, val10)
        var5 = uint + uint(val6, val9)
        var4 = cast[uint, ^mut param0](val5)
        return var4
    }

}

fn [] drop(var0: ^mut 0\Vec[param0]) -> ()  { ret var0
    block0(var2: ^mut 0\Vec[param0]) {
        var3 = 0
        var4 = var3
        goto block1 with var0
    }

    block1() {
        access var4
        access var2
        var7 = *var2
        var6 = var7.1
        var5 = uint == uint(val4, val6)
        split var5 block2 block3
    }

    block2() {
        goto block4 with var0
    }

    block3() {
        access var2
        access var4
        var9 = get_ptr[param0](val2, val4)
        var8 = read[param0](val9)
        drop var8
        access var4
        access var4
        var10 = 1
        var4 = uint + uint(val4, val10)
        goto block5 with var0
    }

    block4(var1: !) {
        access var2
        var13 = *var2
        var12 = var13.0
        var11 = cast[^mut param0, ^()](val12)
        var0 = free(val11)
        return var0
    }

    block5(var0: ()) {
        goto block1 with var0
    }

}

fn [] main() -> uint  { ret var2
    block0() {
        var3 = new[uint]()
        var4 = var3
        access var4
        var5 = &var4
        var6 = 0
        var0 = push[uint](val5, val6)
        access var4
        var7 = &var4
        var8 = 1
        var0 = push[uint](val7, val8)
        access var4
        var9 = &var4
        var10 = 2
        var0 = push[uint](val9, val10)
        var11 = new[0\Vec[uint]]()
        var12 = var11
        access var12
        var13 = &var12
        access var4
        var0 = push[0\Vec[uint]](val13, val4)
        var2 = 0
        drop var12
        return var2
    }

}



