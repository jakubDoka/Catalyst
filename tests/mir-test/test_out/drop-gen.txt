info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { ret var0
    block0(var2: param0) {
        drop var2
        return var0
    }

}

fn [] drop_unused() -> ()  { ret var0
    block0() {
        var3 = 97
        var2 = new(val3)
        drop var2
        return var0
    }

}

fn [] drop_referenced() -> ()  { ret var0
    block0() {
        var4 = 97
        var3 = new(val4)
        var2 = &var3
        var5 = 98
        var0 = set_char(val2, val5)
        drop var3
        return var0
    }

}

fn [] drop_variable() -> ()  { ret var0
    block0() {
        var3 = 97
        var2 = new(val3)
        var4 = var2
        access var4
        var5 = &var4
        var6 = 99
        var0 = set_char(val5, val6)
        drop var4
        return var0
    }

}

fn [] drop_refed_variable() -> ()  { ret var0
    block0() {
        var4 = 97
        var3 = new(val4)
        var2 = &var3
        var5 = var2
        access var5
        var6 = 100
        var0 = set_char(val5, val6)
        drop var3
        return var0
    }

}

fn [] move_in_drop() -> ()  { ret var0
    block0() {
        var3 = 101
        var2 = new(val3)
        var4 = var2
        access var4
        drop var4
        var5 = 102
        var4 = new(val5)
        drop var4
        return var0
    }

}

fn [] drop_cond() -> ()  { ret var0
    block0() {
        var3 = 103
        var2 = new(val3)
        var4 = var2
        var5 = true
        split var5 block1 block2
    }

    block1() {
        access var4
        var1 = drop[0\A](val4)
        goto block3 with var1
    }

    block2() {
        return var0
    }

    block3() {
        return var0
    }

}

fn [] main() -> uint  { ret var2
    block0(var1: !) {
        var0 = drop_unused()
        var0 = drop_referenced()
        var0 = drop_variable()
        var0 = drop_refed_variable()
        var0 = move_in_drop()
        var0 = drop_cond()
        var2 = 0
        return var2
    }

}

fn [] new(var0: char) -> 0\A  { ret var3
    block0(var2: char) {
        var3 ={var4}
        var4 = access var2
        return var3
    }

}

fn [] set_char(var0: ^mut 0\A, var1: char) -> ()  { ret var0
    block0(var2: ^mut 0\A, var3: char) {
        access var2
        var5 = *var2
        var4 = var5.0
        var4 = access var3
        return var0
    }

}

fn [] drop(var0: ^mut 0\A) -> ()  { ret var0
    block0(var2: ^mut 0\A) {
        access var2
        var5 = *var2
        var4 = var5.0
        var3 = putchar(val4)
        var7 = 32
        var6 = putchar(val7)
        return var0
    }

}



