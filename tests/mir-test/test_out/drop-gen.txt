info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { (var3: param0) ret var2
    block0 {
        drop var3
        return var0
    }

}

fn [] drop_unused() -> ()  { () ret var4
    block1 {
        var6 = 97
        var5 = new(val6)
        drop var5
        return var0
    }

}

fn [] drop_referenced() -> ()  { () ret var7
    block2 {
        var10 = 97
        var9 = new(val10)
        var8 = &var9
        var11 = 98
        var7 = set_char(val8, val11)
        drop var9
        return var7
    }

}

fn [] drop_variable() -> ()  { () ret var12
    block3 {
        var14 = 97
        var13 = new(val14)
        var15 = var13
        access var15
        var16 = &var15
        var17 = 99
        var12 = set_char(val16, val17)
        drop var15
        return var12
    }

}

fn [] drop_refed_variable() -> ()  { () ret var18
    block4 {
        var21 = 97
        var20 = new(val21)
        var19 = &var20
        var22 = var19
        access var22
        var23 = 100
        var18 = set_char(val22, val23)
        drop var20
        return var18
    }

}

fn [] move_in_drop() -> ()  { () ret var24
    block5 {
        var26 = 101
        var25 = new(val26)
        var27 = var25
        access var27
        drop var27
        var28 = 102
        var27 = new(val28)
        drop var27
        return var0
    }

}

fn [] drop_cond() -> ()  { () ret var29
    block6 {
        var31 = 103
        var30 = new(val31)
        var32 = var30
        var34 = true
        split var34 block7 block8
    }

    block7 {
        access var32
        var33 = drop[0\A](val32)
        goto block9 with var33
    }

    block8 {
        goto block9
    }

    block9 {
        return var0
    }

}

fn [] main() -> uint  { () ret var35
    block10 {
        var36 = drop_unused()
        var37 = drop_referenced()
        var38 = drop_variable()
        var39 = drop_refed_variable()
        var40 = move_in_drop()
        var41 = drop_cond()
        var35 = 0
        return var35
    }

}

fn [] new(var0: char) -> 0\A  { (var43: char) ret var42
    block11 {
        var42 ={var44}
        var44 = access var43
        return var42
    }

}

fn [] set_char(var0: ^mut 0\A, var1: char) -> ()  { (var46: ^mut 0\A, var47: char) ret var45
    block12 {
        access var46
        var49 = *var46
        var48 = var49.0
        var48 = access var47
        return var0
    }

}

fn [] drop(var0: ^mut 0\A) -> ()  { (var51: ^mut 0\A) ret var50
    block13 {
        access var51
        var54 = *var51
        var53 = var54.0
        var52 = putchar(val53)
        var56 = 32
        var55 = putchar(val56)
        return var0
    }

}



