error: cannot move out of a value more than once
 --> simple-moves\root.ctl:8:10
  |
7 |     drop(a)
  |          - info: first move here
8 |     drop(a)
  |          ^ detected here
  |

error: cannot move out of a value more than once
  --> simple-moves\root.ctl:15:10
   |
13 |         drop(a)
   |              - info: first move here
14 |     } 
15 |     drop(a)
   |          ^ detected here
   |

error: cannot move out of a value more than once
  --> simple-moves\root.ctl:41:10
   |
39 |     drop(a)
   |          - info: first move here
40 |     if 0 == 0 => a = A\{ }
41 |     drop(a)
   |          ^ detected here
   |

error: cannot move out of a value more than once
  --> simple-moves\root.ctl:51:10
   |
50 |         \A~a => drop(a)
   |         ---- info: first move here
...
54 |     drop(e)
   |          ^ detected here
   |

error: cannot move out of a value more than once
  --> simple-moves\root.ctl:72:10
   |
71 |         e {
   |         - info: first move here
...
74 |     drop(e)
   |          ^ detected here
   |

info: mir repr of functions:
 fn [] drop(var0: param0) -> ()  {
    block0(var2: param0) {
        return
    }

}

fn [] double_move() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        access var3
        drop[0\A](val3)
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] conditional_double_move() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        var4 = 0
        var5 = 0
        var6 = uint == uint(val4, val5)
        split var6 block1 block2
    }

    block1() {
        access var3
        var1 = drop[0\A](val3)
        goto block3 with var1
    }

    block2() {
        return
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] conditional_move() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        var4 = 0
        var5 = 0
        var6 = uint == uint(val4, val5)
        split var6 block1 block2
    }

    block1() {
        access var3
        drop[0\A](val3)
        return
    }

    block2() {
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] reassign() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        access var3
        drop[0\A](val3)
        access var3
        var3 ={}
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] conditional_reassign() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        access var3
        drop[0\A](val3)
        var4 = 0
        var5 = 0
        var6 = uint == uint(val4, val5)
        split var6 block1 block2
    }

    block1() {
        access var3
        var3 ={}
        goto block3 with var3
    }

    block2() {
        access var3
        var3 ={}
        goto block3 with var3
    }

    block3() {
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] conditional_incomplete_reassign() -> ()  {
    block0() {
        var2 ={}
        var3 = var2
        access var3
        drop[0\A](val3)
        var4 = 0
        var5 = 0
        var6 = uint == uint(val4, val5)
        split var6 block1 block2
    }

    block1() {
        access var3
        var3 ={}
        goto block3 with var3
    }

    block2() {
        return
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\A](val3)
        return
    }

}

fn [] enum_move() -> ()  {
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        var10 = var5.1
        var11 = var10
        access var11
        var0 = drop[0\A](val11)
        goto block3
    }

    block2() {
        goto block3
    }

    block3() {
        access var5
        var0 = drop[0\E](val5)
        return
    }

}

fn [] enum_just_match() -> ()  {
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        goto block3
    }

    block2() {
        goto block3
    }

    block3() {
        access var5
        var0 = drop[0\E](val5)
        return
    }

}

fn [] enum_whole_move() -> ()  {
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        goto block3
    }

    block2() {
        var10 = var5
        goto block3
    }

    block3() {
        access var5
        var0 = drop[0\E](val5)
        return
    }

}



