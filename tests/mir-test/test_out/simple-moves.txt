error: move out of already moved value
 --> simple-moves\root.ctl:7:10
  |
7 |     drop(a)
  |          - info: previous move of value
8 |     drop(a)
  |          ^ here
  |
  = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of already moved value
  --> simple-moves\root.ctl:13:14
   |
13 |         drop(a)
   |              - info: previous move of value
14 |     } 
15 |     drop(a)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of already moved value
  --> simple-moves\root.ctl:39:10
   |
39 |     drop(a)
   |          - info: previous move of value
40 |     if 0 == 0 => a = A\{ }
41 |     drop(a)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of already moved value
  --> simple-moves\root.ctl:71:9
   |
71 |         e {
   |         - info: previous move of value
72 |         }
73 |     }
74 |     drop(e)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { ret var0
    block0(var2: param0) {
        drop var2
        return var0
    }

}

fn [] double_move() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        access var3
        var0 = drop[0\A](val3)
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] conditional_double_move() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        var5 = 0
        var6 = 0
        var4 = uint == uint(val5, val6)
        split var4 block1 block2
    }

    block1() {
        access var3
        var1 = drop[0\A](val3)
        goto block3 with var1
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] conditional_move() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        var5 = 0
        var6 = 0
        var4 = uint == uint(val5, val6)
        split var4 block1 block2
    }

    block1() {
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

    block2() {
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] reassign() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        access var3
        var0 = drop[0\A](val3)
        access var3
        var3 ={}
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] conditional_reassign() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        access var3
        var0 = drop[0\A](val3)
        var5 = 0
        var6 = 0
        var4 = uint == uint(val5, val6)
        split var4 block1 block2
    }

    block1() {
        access var3
        var3 ={}
        goto block3 with var0
    }

    block2() {
        access var3
        var3 ={}
        goto block3 with var0
    }

    block3(var0: ()) {
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] conditional_incomplete_reassign() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        access var3
        var0 = drop[0\A](val3)
        var5 = 0
        var6 = 0
        var4 = uint == uint(val5, val6)
        split var4 block1 block2
    }

    block1() {
        access var3
        var3 ={}
        goto block3 with var0
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\A](val3)
        return var0
    }

}

fn [] enum_move() -> ()  { ret var0
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        var10 = var5.1
        var11 = var10
        access var11
        var0 = drop[0\A](val11)
        goto block3 with var0
    }

    block2() {
        goto block3 with var0
    }

    block3(var0: ()) {
        access var5
        var0 = drop[0\E](val5)
        return var0
    }

}

fn [] enum_just_match() -> ()  { ret var0
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        goto block3 with var0
    }

    block2() {
        goto block3 with var0
    }

    block3(var0: ()) {
        access var5
        var0 = drop[0\E](val5)
        return var0
    }

}

fn [] enum_whole_move() -> ()  { ret var0
    block0() {
        var4 ={var2, var3}
        var2 = 0
        var3 ={}
        var5 = var4
        access var5
        var6 = var5.0
        var7 = 0
        var8 = u8 == u8(val6, val7)
        var9 = var5.1
        split var8 block1 block2
    }

    block1() {
        goto block3 with var0
    }

    block2() {
        var10 = var5
        goto block3 with var0
    }

    block3(var0: ()) {
        access var5
        var0 = drop[0\E](val5)
        return var0
    }

}



