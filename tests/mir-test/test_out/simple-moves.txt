error: move out of already moved value
 --> simple-moves/root.ctl:8:10
  |
8 |     drop(a)
  |          - info: previous move of value
9 |     drop(a)
  |          ^ here
  |
  = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of already moved value
  --> simple-moves/root.ctl:15:14
   |
15 |         drop(a)
   |              - info: previous move of value
16 |     } 
17 |     drop(a)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of already moved value
  --> simple-moves/root.ctl:83:9
   |
83 |         e {
   |         - info: previous move of value
84 |         }
85 |     }
86 |     drop(e)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { (var3: param0) ret var0
    block0 {
        drop var3
        return var1
    }

}

fn [] double_move() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        access var4
        var1 = drop[0\A](val4)
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] conditional_double_move() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1 {
        access var4
        var1 = drop[0\A](val4)
        goto block3 with var1
    }

    block2 {
        goto block3
    }

    block3 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] conditional_move() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

    block2 {
        goto block3
    }

    block3 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] reassign() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        access var4
        var1 = drop[0\A](val4)
        access var4
        var4 ={}
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] conditional_reassign() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        access var4
        var1 = drop[0\A](val4)
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1 {
        access var4
        var4 ={}
        goto block3 with var1
    }

    block2 {
        access var4
        var4 ={}
        goto block3 with var1
    }

    block3 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] conditional_incomplete_reassign() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        access var4
        var1 = drop[0\A](val4)
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1 {
        access var4
        var4 ={}
        goto block3 with var1
    }

    block2 {
        goto block3
    }

    block3 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] enum_move() -> ()  { () ret var0
    block0 {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var7 = var6.0
        var8 = 0
        var9 = u8 == u8(val7, val8)
        var10 = var6.1
        split var9 block1 block2
    }

    block1 {
        var11 = var6.1
        var12 = var11
        access var12
        var1 = drop[0\A](val12)
        goto block3 with var1
    }

    block2 {
        goto block3 with var1
    }

    block3 {
        access var6
        var1 = drop[0\E](val6)
        return var1
    }

}

fn [] enum_just_match() -> ()  { () ret var0
    block0 {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var7 = var6.0
        var8 = 0
        var9 = u8 == u8(val7, val8)
        var10 = var6.1
        split var9 block1 block2
    }

    block1 {
        goto block3 with var1
    }

    block2 {
        goto block3 with var1
    }

    block3 {
        access var6
        var1 = drop[0\E](val6)
        return var1
    }

}

fn [] enum_whole_move() -> ()  { () ret var0
    block0 {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var7 = var6.0
        var8 = 0
        var9 = u8 == u8(val7, val8)
        var10 = var6.1
        split var9 block1 block2
    }

    block1 {
        goto block3 with var1
    }

    block2 {
        var11 = var6
        goto block3 with var1
    }

    block3 {
        access var6
        var1 = drop[0\E](val6)
        return var1
    }

}



