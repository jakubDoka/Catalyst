error: value is possibly moved more then once
 --> loop-drops/root.ctl:6:5
  |
6 |       loop {
  |  _____-
7 | |         drop(a)
  |                ^ here
8 | |     }
  | |_____- info: the loop
  |
  = note: you can disable move semantics with '#[no_moves]' function attribute
  = note: nonlocal value remains moved even after loop jumps back
  = help: 'break' after the move or move the value beck before next iteration

error: move out of already moved value
  --> loop-drops/root.ctl:20:25
   |
20 |         if true => drop(a)
   |                         - info: previous move of value
21 | else => continue
22 |         break
23 |     }
24 |     drop(a)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: value is possibly moved more then once
  --> loop-drops/root.ctl:28:5
   |
28 |       loop {
   |  _____-
29 | |         if true => drop(a)
   |                           ^ here
30 | | else => break
31 | |     }
   | |_____- info: the loop
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute
   = note: nonlocal value remains moved even after loop jumps back
   = help: 'break' after the move or move the value beck before next iteration

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { ret var0
    block0(var2: param0) {
        drop var2
        return var0
    }

}

fn [] loop_drop() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        goto block1 with var0
    }

    block1() {
        access var3
        var0 = drop[4\A](val3)
        goto block1 with var0
    }

}

fn [] loop_break_drop() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        goto block1 with var0
    }

    block1() {
        access var3
        var0 = drop[4\A](val3)
        goto block2 with var0
    }

    block2() {
        return var0
    }

}

fn [] linear_loop_branch_drop() -> ()  { ret var0
    block0(var1: !) {
        var2 ={}
        var3 = var2
        goto block1 with var0
    }

    block1() {
        var4 = true
        split var4 block2 block3
    }

    block2() {
        access var3
        var1 = drop[4\A](val3)
        goto block4 with var1
    }

    block3() {
        goto block1 with var0
    }

    block4(var1: !) {
        goto block5 with var0
    }

    block5(var1: !) {
        access var3
        var0 = drop[4\A](val3)
        return var0
    }

}

fn [] loop_branch_drop() -> ()  { ret var0
    block0() {
        var2 ={}
        var3 = var2
        goto block1 with var0
    }

    block1() {
        var4 = true
        split var4 block2 block3
    }

    block2() {
        access var3
        var1 = drop[4\A](val3)
        goto block4 with var1
    }

    block3() {
        goto block5 with var0
    }

    block4(var1: !) {
        goto block1 with var0
    }

    block5() {
        return var0
    }

}

fn [] loop_drop_and_move_in() -> ()  { ret var0
    block0(var1: !) {
        var2 ={}
        var3 = var2
        goto block1 with var0
    }

    block1() {
        var4 = true
        split var4 block2 block3
    }

    block2() {
        access var3
        var1 = drop[4\A](val3)
        goto block4 with var1
    }

    block3() {
        return var0
    }

    block4(var1: !) {
        access var3
        var3 ={}
        goto block1 with var0
    }

}



