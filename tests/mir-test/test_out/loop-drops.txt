info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { (var3: param0) ret var0
    block0 {
        drop var3
        return var1
    }

}

fn [] loop_drop() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        goto block1
    }

    block1 {
        access var4
        var1 = drop[0\A](val4)
        goto block1
    }

}

fn [] loop_break_drop() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        goto block1
    }

    block1 {
        access var4
        var1 = drop[0\A](val4)
        goto block2
    }

    block2 {
        return var1
    }

}

fn [] linear_loop_branch_drop() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        goto block1
    }

    block1 {
        var5 = 1
        split var5 block2 block3
    }

    block2 {
        access var4
        var1 = drop[0\A](val4)
        goto block4 with var1
    }

    block3 {
        goto block1
    }

    block4 {
        goto block5
    }

    block5 {
        access var4
        var1 = drop[0\A](val4)
        return var1
    }

}

fn [] loop_branch_drop() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        goto block1
    }

    block1 {
        var5 = 1
        split var5 block2 block3
    }

    block2 {
        access var4
        var1 = drop[0\A](val4)
        goto block4 with var1
    }

    block3 {
        goto block5
    }

    block4 {
        goto block1
    }

    block5 {
        return var1
    }

}

fn [] loop_drop_and_move_in() -> ()  { () ret var0
    block0 {
        var3 ={}
        var4 = var3
        goto block1
    }

    block1 {
        var5 = 1
        split var5 block2 block3
    }

    block2 {
        access var4
        var1 = drop[0\A](val4)
        goto block4 with var1
    }

    block3 {
        goto block4
    }

    block4 {
        access var4
        var4 ={}
        goto block1
    }

}



