error: expected 'entry' | 'water_drop' | 'compile_time' | 'macro' | 'inline' but got 'no_moves'
 --> macro-impl\deps\github.com\jakubDoka\water\main\root\ptr.ctl:2:3
  |
2 | #[no_moves]
  |   ^^^^^^^^ token located here
  |
  = info: grouped items -> list -> item -> top level attribute -> wrapped -> top level attribute

error: expected 'entry' | 'water_drop' | 'compile_time' | 'macro' | 'inline' but got 'no_moves'
 --> macro-impl\deps\github.com\jakubDoka\water\main\root\ptr.ctl:7:3
  |
7 | #[no_moves]
  |   ^^^^^^^^ token located here
  |
  = info: grouped items -> list -> item -> top level attribute -> wrapped -> top level attribute

error: cannot move out of a pointer
 --> macro-impl\deps\github.com\jakubDoka\water\main\root\ptr.ctl:4:13
  |
4 |     *dest = value
  |             ^^^^^ discovered here
  |
  = info: you can disable move validation with `#[no_move]`

error: expected '*' but got '^'
  --> macro-impl\root.ctl:45:18
   |
45 |         ptr\read(^ s.lexer)
   |                  ^ token located here
   |
   = info: grouped items -> list -> item -> impl -> list -> impl item -> function definition -> function body -> list -> expr -> unit expr -> call -> list -> expr -> unit expr

info: mir repr of functions:
 fn [] next(var0: 1\MacroLexer) -> 1\MacroToken  {
    block0(var2: 1\MacroLexer) {
        access var2
        var3 = ctl_lexer_next(val2)
        return var3
    }

}

fn [] write(var0: ^mut param0, var1: param0) -> ()  {
    block0(var2: ^mut param0, var3: param0) {
        access var2
        var4 = *var2
        var4 = access var3
        return
    }

}

fn [] read(var0: ^param0) -> param0  {
    block0(var2: ^param0) {
        access var2
        var4 = *var2
        return var4
    }

}

fn "default" [] new(var0: ^2\Swap, var1: 1\MacroLexer) -> ()  {
    block0(var2: ^2\Swap, var3: 1\MacroLexer) {
        access var2
        var6 ={var4, var5}
        var4 ={var7, var8}
        var7 = 0
        var8 ={var9, var10}
        access var3
        var9 = next(val3)
        access var3
        var10 = next(val3)
        var5 = access var3
        var0 = write[2\Swap](val2, val6)
        return
    }

}

fn "default" [] next(var0: ^2\Swap) -> 4\Option[1\MacroToken]  {
    block0(var2: ^2\Swap) {
        var3 ={var4, var5}
        var4 = 1
        access var2
        var7 = *var2
        var6 = var7.0
        var8 = var6.0
        var9 = 0
        var10 = u8 == u8(val8, val9)
        split var10 block1 block2
    }

    block1() {
        var11 = var6.1
        var12 = var11.0
        var13 = var12
        var14 = var11.1
        var15 = var14
        access var2
        var17 = *var2
        var16 = var17.0
        var16 ={var18, var19}
        var18 = 1
        var19 ={var20}
        var20 = access var13
        var5 = access var15
        goto block3 with var5
    }

    block2() {
        var21 = var6.0
        var22 = 1
        var23 = u8 == u8(val21, val22)
        split var23 block4 block5
    }

    block3(var5: 1\MacroToken) {
        return var3
    }

    block4() {
        var24 = var6.1
        var25 = var24.0
        var26 = var25
        access var2
        var28 = *var2
        var27 = var28.0
        var27 ={var29}
        var29 = 2
        var5 = access var26
        goto block3 with var5
    }

    block5() {
        var3 ={var30}
        var30 = 0
        return var3
    }

}

fn "default" [] drop(var0: ^2\Swap) -> 1\MacroLexer  {
    block0(var2: ^2\Swap) {
        var3 = read[1\MacroLexer]()
        return var3
    }

}



