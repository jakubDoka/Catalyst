error: move out of already moved value
  --> partial-moves/root.ctl:17:12
   |
17 |     drop(b.a0)
   |            -- info: previous move of value
18 |     drop(b.a1)
19 |     drop(b.a0)
   |            ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:24:12
   |
24 |     drop(b.a0)
   |            -- info: move occurs earlier here
25 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:37:25
   |
37 |     if 0 == 0 => drop(b.a0)
   |                         -- info: move occurs earlier here
38 | 
39 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to partially moved value
  --> partial-moves/root.ctl:52:12
   |
52 |     drop(b.a0)
   |            -- info: move occurs earlier here
53 |     let a = ^b
   |              ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to already moved value
  --> partial-moves/root.ctl:58:10
   |
58 |     drop(b)
   |          - info: previous move of value
59 |     let a = ^b.a0
   |                ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { (var2: param0) ret var3
    block0 {
        drop var2
        return var0
    }

}

fn [] double_move() -> ()  { () ret var4
    block1 {
        var5 = new()
        var6 = var5
        access var6
        var8 = var6.0
        var7 = drop[0\A](val8)
        access var6
        var10 = var6.1
        var9 = drop[0\A](val10)
        access var6
        var11 = var6.0
        var4 = drop[0\A](val11)
        return var4
    }

}

fn [] move_of_partially_moved() -> ()  { () ret var12
    block2 {
        var13 = new()
        var14 = var13
        access var14
        var16 = var14.0
        var15 = drop[0\A](val16)
        access var14
        var12 = drop[0\B](val14)
        return var12
    }

}

fn [] partial_move_and_assign() -> ()  { () ret var17
    block3 {
        var18 = new()
        var19 = var18
        access var19
        var21 = var19.0
        var20 = drop[0\A](val21)
        access var19
        var22 = var19.0
        var22 ={}
        access var19
        var17 = drop[0\B](val19)
        return var17
    }

}

fn [] conditional_partial_move() -> ()  { () ret var23
    block4 {
        var24 = new()
        var25 = var24
        var28 = 0
        var29 = 0
        var27 = uint == uint(val28, val29)
        split var27 block5 block6
    }

    block5 {
        access var25
        var30 = var25.0
        var26 = drop[0\A](val30)
        goto block8
    }

    block6 {
        goto block7
    }

    block8 {
        var31 = var25.0
        goto block7 with var26
    }

    block7 {
        access var25
        var23 = drop[0\B](val25)
        return var23
    }

}

fn [] conditional_assign() -> ()  { () ret var32
    block9 {
        var33 = new()
        var34 = var33
        access var34
        var36 = var34.0
        var35 = drop[0\A](val36)
        var39 = 0
        var40 = 0
        var38 = uint == uint(val39, val40)
        split var38 block10 block11
    }

    block10 {
        access var34
        var41 = var34.0
        var41 ={}
        goto block12 with var0
    }

    block11 {
        return var0
    }

    block12 {
        access var34
        var32 = drop[0\B](val34)
        return var32
    }

}

fn [] reference_partial_move() -> ()  { () ret var42
    block13 {
        var43 = new()
        var44 = var43
        access var44
        var46 = var44.0
        var45 = drop[0\A](val46)
        access var44
        var47 = &var44
        var48 = var47
        return var0
    }

}

fn [] partial_reference_move() -> ()  { () ret var49
    block14 {
        var50 = new()
        var51 = var50
        access var51
        var52 = drop[0\B](val51)
        access var51
        var54 = var51.0
        var53 = &var54
        var55 = var53
        return var0
    }

}

fn [] new() -> 0\B  { () ret var56
    block15 {
        var56 ={var57, var58}
        var57 ={}
        var58 ={}
        return var56
    }

}



