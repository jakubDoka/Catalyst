error: move out of already moved value
  --> partial-moves/root.ctl:17:12
   |
17 |     drop(b.a0)
   |            -- info: previous move of value
18 |     drop(b.a1)
19 |     drop(b.a0)
   |            ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to already moved value
  --> partial-moves/root.ctl:58:10
   |
58 |     drop(b)
   |          - info: previous move of value
59 |     let a = ^b.a0
   |                ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: borrowc repr of functions:
fn [: ] drop(param0) -> () { (var3: param0) ret var0
    block0 {
        drop var3
        return var1
    }

}

fn [] double_move() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var5 = var4.0
        var1 = drop[3\A](val5)
        var6 = var4.1
        var1 = drop[3\A](val6)
        var7 = var4.0
        var1 = drop[3\A](val7)
        return var1
    }

}

fn [] move_of_partially_moved() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var5 = var4.0
        var1 = drop[3\A](val5)
        var1 = drop[3\B](val4)
        return var1
    }

}

fn [] partial_move_and_assign() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var5 = var4.0
        var1 = drop[3\A](val5)
        var6 = var4.0
        var6 ={}
        var1 = drop[3\B](val4)
        return var1
    }

}

fn [] conditional_partial_move() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1 {
        var8 = var4.0
        var1 = drop[3\A](val8)
        goto block4
    }

    block2 {
        goto block5
    }

    block4 {
        var9 = var4.0
        goto block3 with var1
    }

    block5 {
        var10 = var4.0
        goto block3
    }

    block3 {
        var1 = drop[3\B](val4)
        return var1
    }

}

fn [] conditional_assign() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var5 = var4.0
        var1 = drop[3\A](val5)
        var7 = 0
        var8 = 0
        var6 = uint == uint(val7, val8)
        split var6 block1 block2
    }

    block1 {
        var9 = var4.0
        var9 ={}
        goto block3 with var1
    }

    block2 {
        return var1
    }

    block3 {
        var1 = drop[3\B](val4)
        return var1
    }

}

fn [] reference_partial_move() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var5 = var4.0
        var1 = drop[3\A](val5)
        var6 = &var4
        var7 = var6
        return var1
    }

}

fn [] partial_reference_move() -> () { () ret var0
    block0 {
        var3 = new()
        var4 = var3
        var1 = drop[3\B](val4)
        var6 = var4.0
        var5 = &var6
        var7 = var5
        return var1
    }

}

fn [] new() -> 3\B { () ret var0
    block0 {
        var0 ={var3, var4}
        var3 ={}
        var4 ={}
        return var0
    }

}



