error: move out of already moved value
  --> partial-moves/root.ctl:17:12
   |
17 |     drop(b.a0)
   |            -- info: previous move of value
18 |     drop(b.a1)
19 |     drop(b.a0)
   |            ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:24:12
   |
24 |     drop(b.a0)
   |            -- info: move occurs earlier here
25 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:37:25
   |
37 |     if 0 == 0 => drop(b.a0)
   |                         -- info: move occurs earlier here
38 | 
39 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to partially moved value
  --> partial-moves/root.ctl:52:12
   |
52 |     drop(b.a0)
   |            -- info: move occurs earlier here
53 |     let a = ^b
   |              ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to already moved value
  --> partial-moves/root.ctl:58:10
   |
58 |     drop(b)
   |          - info: previous move of value
59 |     let a = ^b.a0
   |                ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { (var3: param0) ret var2
    block0 {
        drop var3
        return var0
    }

}

fn [] double_move() -> ()  { () ret var4
    block1 {
        var5 = new()
        var6 = var5
        access var6
        var8 = var6.0
        var7 = drop[0\A](val8)
        access var6
        var10 = var6.1
        var9 = drop[0\A](val10)
        access var6
        var12 = var6.0
        var11 = drop[0\A](val12)
        return var0
    }

}

fn [] move_of_partially_moved() -> ()  { () ret var13
    block2 {
        var14 = new()
        var15 = var14
        access var15
        var17 = var15.0
        var16 = drop[0\A](val17)
        access var15
        var18 = drop[0\B](val15)
        return var0
    }

}

fn [] partial_move_and_assign() -> ()  { () ret var19
    block3 {
        var20 = new()
        var21 = var20
        access var21
        var23 = var21.0
        var22 = drop[0\A](val23)
        access var21
        var24 = var21.0
        var24 ={}
        access var21
        var25 = drop[0\B](val21)
        return var0
    }

}

fn [] conditional_partial_move() -> ()  { () ret var26
    block4 {
        var27 = new()
        var28 = var27
        var31 = 0
        var32 = 0
        var30 = uint == uint(val31, val32)
        split var30 block5 block6
    }

    block5 {
        access var28
        var33 = var28.0
        var29 = drop[0\A](val33)
        goto block8
    }

    block6 {
        goto block7
    }

    block8 {
        var34 = var28.0
        goto block7 with var29
    }

    block7 {
        access var28
        var35 = drop[0\B](val28)
        return var0
    }

}

fn [] conditional_assign() -> ()  { () ret var36
    block9 {
        var37 = new()
        var38 = var37
        access var38
        var40 = var38.0
        var39 = drop[0\A](val40)
        var43 = 0
        var44 = 0
        var42 = uint == uint(val43, val44)
        split var42 block10 block11
    }

    block10 {
        access var38
        var45 = var38.0
        var45 ={}
        goto block12 with var0
    }

    block11 {
        return var0
    }

    block12 {
        access var38
        var46 = drop[0\B](val38)
        return var0
    }

}

fn [] reference_partial_move() -> ()  { () ret var47
    block13 {
        var48 = new()
        var49 = var48
        access var49
        var51 = var49.0
        var50 = drop[0\A](val51)
        access var49
        var52 = &var49
        var53 = var52
        return var0
    }

}

fn [] partial_reference_move() -> ()  { () ret var54
    block14 {
        var55 = new()
        var56 = var55
        access var56
        var57 = drop[0\B](val56)
        access var56
        var59 = var56.0
        var58 = &var59
        var60 = var58
        return var0
    }

}

fn [] new() -> 0\B  { () ret var61
    block15 {
        var61 ={var62, var63}
        var62 ={}
        var63 ={}
        return var61
    }

}



