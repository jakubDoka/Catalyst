error: move out of already moved value
  --> partial-moves/root.ctl:17:12
   |
17 |     drop(b.a0)
   |            -- info: previous move of value
18 |     drop(b.a1)
19 |     drop(b.a0)
   |            ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:24:12
   |
24 |     drop(b.a0)
   |            -- info: move occurs earlier here
25 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: move out of partially moved value
  --> partial-moves/root.ctl:37:25
   |
37 |     if 0 == 0 => drop(b.a0)
   |                         -- info: move occurs earlier here
38 | 
39 |     drop(b)
   |          ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to partially moved value
  --> partial-moves/root.ctl:52:12
   |
52 |     drop(b.a0)
   |            -- info: move occurs earlier here
53 |     let a = ^b
   |              ^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

error: reference to already moved value
  --> partial-moves/root.ctl:58:10
   |
58 |     drop(b)
   |          - info: previous move of value
59 |     let a = ^b.a0
   |                ^^ here
   |
   = note: you can disable move semantics with '#[no_moves]' function attribute

info: mir repr of functions:
fn [] drop(var0: param0) -> ()  { ret var0
    block0(var2: param0) {
        drop var2
        return var0
    }

}

fn [] double_move() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        var0 = drop[0\A](val4)
        access var3
        var5 = var3.1
        var0 = drop[0\A](val5)
        access var3
        var6 = var3.0
        var0 = drop[0\A](val6)
        return var0
    }

}

fn [] move_of_partially_moved() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        var0 = drop[0\A](val4)
        access var3
        var0 = drop[0\B](val3)
        return var0
    }

}

fn [] partial_move_and_assign() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        var0 = drop[0\A](val4)
        access var3
        var5 = var3.0
        var5 ={}
        access var3
        var0 = drop[0\B](val3)
        return var0
    }

}

fn [] conditional_partial_move() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        var5 = 0
        var6 = 0
        var4 = uint == uint(val5, val6)
        split var4 block1 block2
    }

    block1() {
        access var3
        var7 = var3.0
        var1 = drop[0\A](val7)
        goto block4 with var0
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\B](val3)
        return var0
    }

    block4() {
        var8 = var3.0
        goto block3 with var1
    }

}

fn [] conditional_assign() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        var0 = drop[0\A](val4)
        var6 = 0
        var7 = 0
        var5 = uint == uint(val6, val7)
        split var5 block1 block2
    }

    block1() {
        access var3
        var8 = var3.0
        var8 ={}
        goto block3 with var0
    }

    block2() {
        return var0
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\B](val3)
        return var0
    }

}

fn [] reference_partial_move() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        var0 = drop[0\A](val4)
        access var3
        var5 = &var3
        var6 = var5
        return var0
    }

}

fn [] partial_reference_move() -> ()  { ret var0
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var0 = drop[0\B](val3)
        access var3
        var5 = var3.0
        var4 = &var5
        var6 = var4
        return var0
    }

}

fn [] new() -> 0\B  { ret var2
    block0() {
        var2 ={var3, var4}
        var3 ={}
        var4 ={}
        return var2
    }

}



