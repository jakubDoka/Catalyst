error: cannot move out of a value more than once
  --> partial-moves\root.ctl:16:12
   |
14 |     drop(b.a0)
   |            -- info: first move here
15 |     drop(b.a1)
16 |     drop(b.a0)
   |            ^^ detected here
   |

error: moving partially moved value
  --> partial-moves\root.ctl:20:12
   |
20 |     drop(b.a0)
   |            -- info: value partially moved here
21 |     drop(b)
   |          ^ occurred here
   |

error: moving partially moved value
  --> partial-moves\root.ctl:31:25
   |
31 |     if 0 == 0 => drop(b.a0)
   |                         -- info: value partially moved here
32 |     drop(b)
   |          ^ occurred here
   |

info: mir repr of functions:
 fn [] drop(var0: param0) -> ()  {
    block0(var2: param0) {
        return
    }

}

fn [] double_move() -> ()  {
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        drop[0\A](val4)
        access var3
        var5 = var3.1
        drop[0\A](val5)
        access var3
        var6 = var3.0
        var0 = drop[0\A](val6)
        return
    }

}

fn [] move_of_partially_moved() -> ()  {
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        drop[0\A](val4)
        access var3
        var0 = drop[0\B](val3)
        return
    }

}

fn [] partial_move_and_assign() -> ()  {
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        drop[0\A](val4)
        access var3
        var5 = var3.0
        var5 ={}
        access var3
        var0 = drop[0\B](val3)
        return
    }

}

fn [] conditional_partial_move() -> ()  {
    block0() {
        var2 = new()
        var3 = var2
        var4 = 0
        var5 = 0
        var6 = uint == uint(val4, val5)
        split var6 block1 block2
    }

    block1() {
        access var3
        var7 = var3.0
        var1 = drop[0\A](val7)
        goto block3 with var1
    }

    block2() {
        return
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\B](val3)
        return
    }

}

fn [] conditional_assign() -> ()  {
    block0() {
        var2 = new()
        var3 = var2
        access var3
        var4 = var3.0
        drop[0\A](val4)
        var5 = 0
        var6 = 0
        var7 = uint == uint(val5, val6)
        split var7 block1 block2
    }

    block1() {
        access var3
        var8 = var3.0
        var8 ={}
        goto block3 with var8
    }

    block2() {
        return
    }

    block3(var1: !) {
        access var3
        var0 = drop[0\B](val3)
        return
    }

}

fn [] new() -> 0\B  {
    block0() {
        var2 ={var3, var4}
        var3 ={}
        var4 ={}
        return var2
    }

}



