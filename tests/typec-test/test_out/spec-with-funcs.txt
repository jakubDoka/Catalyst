error: colliding implementations for type 'uint'
  --> spec-with-funcs/root.ctl:8:6
   |
 8 | impl Glue for uint {
   |      ------------- info: implementation that already satisfies
 9 |     fn new -> Self => 0
10 |     fn [T] use_on(s: ^Self, value: T) -> Glued\[T] => \{inner: value}
11 | }
12 | impl Glue for uint
   |      ^^^^^^^^^^^^^ it is colliding with this implementation
   |
   = info: 'uint' already implements 'Glue'

error: implementation is missing functions
  --> spec-with-funcs/root.ctl:12:6
   |
12 | impl Glue for uint
   |      ^^^^^^^^^^^^^ here
   |
   = help: missing: new, use_on

error: implementation is missing functions
  --> spec-with-funcs/root.ctl:13:6
   |
13 | impl Glue for u32
   |      ^^^^^^^^^^^^ here
   |
   = help: missing: new, use_on

error: dataflow of impl method does not match spec
  --> spec-with-funcs/root.ctl:4:6
   |
 4 | spec Glue {
   |      ---- info: spec is defined here
 5 |     fn new -> Self
   |        --- info: this function has different dataflow
 6 |     fn [T] use_on(s: ^Self, value: T) -> Glued\[T]
 7 | }
 8 | impl Glue for uint {
 9 |     fn new -> Self => 0
10 |     fn [T] use_on(s: ^Self, value: T) -> Glued\[T] => \{inner: value}
11 | }
12 | impl Glue for uint
13 | impl Glue for u32
14 | struct A
15 | impl Glue for A {
16 |     fn new -> uint => 0
   |        ^^^ here
   |
   = info: found mismatches:
           ret 1\A

error: amount of arguments of impl method does not match spec
  --> spec-with-funcs/root.ctl:4:6
   |
 4 | spec Glue {
   |      ---- info: spec is defined here
 5 |     fn new -> Self
 6 |     fn [T] use_on(s: ^Self, value: T) -> Glued\[T]
   |            ------ info: this function takes 2 arguments
 7 | }
 8 | impl Glue for uint {
 9 |     fn new -> Self => 0
10 |     fn [T] use_on(s: ^Self, value: T) -> Glued\[T] => \{inner: value}
11 | }
12 | impl Glue for uint
13 | impl Glue for u32
14 | struct A
15 | impl Glue for A {
16 |     fn new -> uint => 0
17 |     fn [T] use_on(s: ^uint) -> Glued\[T] => \{inner: value}
   |            ^^^^^^ impl method takes 1 arguments
   |
   = info: expected 2 but got 1

error: implementation is missing functions
  --> spec-with-funcs/root.ctl:15:6
   |
15 | impl Glue for A {
   |      ^^^^^^^^^^ here
   |
   = help: missing: new, use_on

error: not all call parameters can be inferred
  --> spec-with-funcs/root.ctl:33:39
   |
33 | fn main() -> uint => uint\new() + take(0)
   |                                       ^^^ here
   |
   = info: missing parameters: #1
   = help: provide the parameters (works on methods too) (<func_path>\[<ty_param>, ...](<expr_arg>, ...))

error: scope item not found
  --> spec-with-funcs/root.ctl:17:54
   |
17 |     fn [T] use_on(s: ^uint) -> Glued\[T] => \{inner: value}
   |                                                      ^^^^^ this does not exist or is not imported
   |
   = help: expected variable or enum
   = info: debug: queried 'value'

error: missing fields in struct constructor
  --> spec-with-funcs/root.ctl:17:45
   |
17 |     fn [T] use_on(s: ^uint) -> Glued\[T] => \{inner: value}
   |                                             ^^^^^^^^^^^^^^^ here
   |
   = error: missing: inner

info: tir repr of functions:
fn [: Glue, ] glue_up(var0: param1) -> 1\Glued[param1] return {
    Glue\use_on[param0, param1](^Glue\new[param0](), var0)
}

fn [, : GenericSpec[param0]] take(var0: param0) -> param1 return GenericSpec\take[param0, param1](var0)

fn [] new() -> uint return 0

fn [] use_on(var0: ^uint, var1: param0) -> 1\Glued[param0] return 1\Glued[param0]\{var1}

fn [] new() -> uint return 0

fn [] new() -> () return {
}

fn [] take(var0: uint) -> uint return var0

fn [] write(var0: ^mut param0, var1: param0) -> () return {
    *var0 = var1
}

fn [] read(var0: ^param0) -> param0 return *var0

fn [] new() -> 0\Vec[param0] return {
    0\Vec[param0]\{cast[uint, ^mut param0](0), 0, 0}
}

fn [] with_capacity(var0: uint) -> 0\Vec[param0] return {
    0\Vec[param0]\{cast[^mut (), ^mut param0](malloc(uint * uint(var0, sizeof[param0]()))), 0, var0}
}

fn [] push(var0: ^mut 0\Vec[param0], var1: param0) -> () return {
    if uint == uint(*var0.1, *var0.2) {
        grow[param0](var0)
    }
    write[param0](get_mut_ptr[param0](var0, *var0.1), var1)
    *var0.1 = uint + uint(*var0.1, 1)
}

fn [] grow(var0: ^mut 0\Vec[param0]) -> () return {
    let var1 = if uint == uint(*var0.2, 0) {
        1
    } else {
        uint * uint(*var0.2, 2)
    }
    let var2 = malloc(uint * uint(var1, sizeof[param0]()))
    memcpy(var2, cast[^mut param0, ^()](*var0.0), uint * uint(*var0.1, sizeof[param0]()))
    free(cast[^mut param0, ^()](*var0.0))
    *var0.0 = cast[^mut (), ^mut param0](var2)
}

fn [] get_ptr(var0: ^0\Vec[param0], var1: uint) -> ^param0 return {
    cast[uint, ^param0](uint + uint(cast[^mut param0, uint](*var0.0), uint * uint(var1, sizeof[param0]())))
}

fn [] get_mut_ptr(var0: ^mut 0\Vec[param0], var1: uint) -> ^mut param0 return {
    cast[uint, ^mut param0](uint + uint(cast[^mut param0, uint](*var0.0), uint * uint(var1, sizeof[param0]())))
}

fn [] drop(var0: ^mut 0\Vec[param0]) -> () return {
    let mut var1 = 0
    loop id0 if uint == uint(var1, *var0.1) {
        break id0 
    } else {
        read[param0](get_ptr[param0](var0, var1))
        var1 = uint + uint(var1, 1)
    }
    free(cast[^mut param0, ^()](*var0.0))
}



