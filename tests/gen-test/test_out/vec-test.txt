error: expected '\n' | ';' but got 'if'
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:62:14
   |
62 |         loop if i == self.len => break
   |              ^^ token located here
   |
   = info: grouped items -> list -> item -> impl -> list -> impl item -> function definition -> function body -> list

error: expected Ident | '\' | 'return' | Int | Char | Bool | 'match' | 'if' | 'let' | Operator but got 'else'
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:63:9
   |
63 |         else {
   |         ^^^^ token located here
   |
   = info: grouped items -> list -> item -> impl -> list -> impl item -> function definition -> function body -> list -> expr -> unit expr

error: function not found
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:37:15
   |
37 |         *self.get(self.len - 1) = val
   |               ^^^ this does not exist
   |
   = info: queried 'struct1\get'

error: variable or enum not found
  --> vec-test\deps\github.com\jakubDoka\water\main\root\vec.ctl:62:9
   |
62 |         loop if i == self.len => break
   |         ^^^^ this does not exist
   |
   = info: queried 'loop'

error: function not found
  --> vec-test\root.ctl:13:8
   |
13 |     vv.get_mut(0).push(3)
   |        ^^^^^^^ this does not exist
   |
   = info: queried 'struct1\get_mut'

info: generated ir:
main function u0:0() -> i64 fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    ss2 = explicit_slot 24
    ss3 = explicit_slot 24
    sig0 = (i64 sret) fast
    sig1 = (i64, i64) fast
    sig2 = (i64, i64) fast
    sig3 = (i64, i64) fast
    sig4 = (i64 sret) fast
    sig5 = (i64, i64) fast
    sig6 = (i64) fast
    fn0 = colocated u0:2 sig0
    fn1 = colocated u0:3 sig1
    fn2 = colocated u0:3 sig2
    fn3 = colocated u0:3 sig3
    fn4 = colocated u0:4 sig4
    fn5 = colocated u0:5 sig5
    fn6 = colocated u0:1 sig6

block0:
    v0 = stack_addr.i64 ss0
    call fn0(v0)
    v1 = stack_addr.i64 ss1
    v2 = stack_addr.i64 ss0
    v3 = load.i64 aligned v2
    v4 = load.i64 aligned v2+8
    v5 = load.i64 aligned v2+16
    store aligned v3, v1
    store aligned v4, v1+8
    store aligned v5, v1+16
    v6 = stack_addr.i64 ss1
    v7 = iconst.i64 0
    call fn1(v6, v7)  ; v7 = 0
    v8 = stack_addr.i64 ss1
    v9 = iconst.i64 1
    call fn2(v8, v9)  ; v9 = 1
    v10 = stack_addr.i64 ss1
    v11 = iconst.i64 2
    call fn3(v10, v11)  ; v11 = 2
    v12 = stack_addr.i64 ss2
    call fn4(v12)
    v13 = stack_addr.i64 ss3
    v14 = stack_addr.i64 ss2
    v15 = load.i64 aligned v14
    v16 = load.i64 aligned v14+8
    v17 = load.i64 aligned v14+16
    store aligned v15, v13
    store aligned v16, v13+8
    store aligned v17, v13+16
    v18 = stack_addr.i64 ss3
    v19 = stack_addr.i64 ss1
    call fn5(v18, v19)
    v20 = iconst.i64 0
    v21 = stack_addr.i64 ss3
    call fn6(v21)
    return v20  ; v20 = 0
}
push function u0:0(i64, i64) fast {
    sig0 = (i64) fast
    sig1 = (i64) fast
    fn0 = colocated u0:8 sig0
    fn1 = colocated u0:6 sig1

block0(v0: i64, v1: i64):
    v2 = load.i64 v0+8
    v3 = load.i64 v0+16
    v4 = icmp eq v2, v3
    brnz v4, block1
    jump block2

block2:
    return

block1:
    call fn0(v0)
    jump block3

block3:
    v5 = iconst.i64 1
    v6 = load.i64 v0+8
    v7 = iadd v6, v5  ; v5 = 1
    store v7, v0+8
    call fn1(v1)
    return
}
grow function u0:0(i64) fast {
    sig0 = (i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    fn0 = u0:12 sig0
    fn1 = u0:14 sig1
    fn2 = u0:15 sig2

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0+16
    v3 = icmp eq v2, v1  ; v1 = 0
    brnz v3, block1
    jump block2

block2:
    v4 = iconst.i64 2
    v5 = load.i64 v0+16
    v6 = imul v5, v4  ; v4 = 2
    jump block3(v6)

block1:
    v7 = iconst.i64 1
    jump block3(v7)  ; v7 = 1

block3(v8: i64):
    v9 = iconst.i64 24
    v10 = imul v8, v9  ; v9 = 24
    v11 = call fn0(v10)
    v12 = load.i64 v0
    v13 = iconst.i64 24
    v14 = load.i64 v0+8
    v15 = imul v14, v13  ; v13 = 24
    call fn1(v11, v12, v15)
    v16 = load.i64 v0
    call fn2(v16)
    store v11, v0
    return
}
drop function u0:0(i64) fast {
    sig0 = (i64) windows_fastcall
    fn0 = u0:15 sig0

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0
    call fn0(v2)
    return
}
new function u0:0(i64 sret) fast {
block0(v0: i64):
    v1 = iconst.i64 0
    store v1, v0  ; v1 = 0
    v2 = iconst.i64 0
    store v2, v0+8  ; v2 = 0
    v3 = iconst.i64 0
    store v3, v0+16  ; v3 = 0
    return
}
push function u0:0(i64, i64) fast {
    ss0 = explicit_slot 8
    sig0 = (i64) fast
    fn0 = colocated u0:19 sig0

block0(v0: i64, v1: i64):
    stack_store v1, ss0
    v2 = load.i64 v0+8
    v3 = load.i64 v0+16
    v4 = icmp eq v2, v3
    brnz v4, block1
    jump block2

block2:
    return

block1:
    call fn0(v0)
    jump block3

block3:
    v5 = iconst.i64 1
    v6 = load.i64 v0+8
    v7 = iadd v6, v5  ; v5 = 1
    store v7, v0+8
    v8 = stack_addr.i64 ss0
    return
}
grow function u0:0(i64) fast {
    sig0 = (i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    fn0 = u0:12 sig0
    fn1 = u0:14 sig1
    fn2 = u0:15 sig2

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0+16
    v3 = icmp eq v2, v1  ; v1 = 0
    brnz v3, block1
    jump block2

block2:
    v4 = iconst.i64 2
    v5 = load.i64 v0+16
    v6 = imul v5, v4  ; v4 = 2
    jump block3(v6)

block1:
    v7 = iconst.i64 1
    jump block3(v7)  ; v7 = 1

block3(v8: i64):
    v9 = iconst.i64 8
    v10 = imul v8, v9  ; v9 = 8
    v11 = call fn0(v10)
    v12 = load.i64 v0
    v13 = iconst.i64 8
    v14 = load.i64 v0+8
    v15 = imul v14, v13  ; v13 = 8
    call fn1(v11, v12, v15)
    v16 = load.i64 v0
    call fn2(v16)
    store v11, v0
    return
}
new function u0:0(i64 sret) fast {
block0(v0: i64):
    v1 = iconst.i64 0
    store v1, v0  ; v1 = 0
    v2 = iconst.i64 0
    store v2, v0+8  ; v2 = 0
    v3 = iconst.i64 0
    store v3, v0+16  ; v3 = 0
    return
}
drop function u0:0(i64) fast {
    sig0 = (i64) windows_fastcall
    fn0 = u0:15 sig0

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0
    call fn0(v2)
    return
}


