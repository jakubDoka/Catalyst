info: generated ir:
main function u0:0() -> i64 fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    ss2 = explicit_slot 24
    ss3 = explicit_slot 24
    sig0 = (i64 sret) fast
    sig1 = (i64, i64) fast
    sig2 = (i64 sret) fast
    sig3 = (i64, i64) fast
    sig4 = (i64, i64) -> i64 fast
    sig5 = (i64, i64) -> i64 fast
    sig6 = (i64, i64) -> i64 fast
    sig7 = (i64) fast
    fn0 = colocated u16789504:2116 sig0
    fn1 = colocated u16789760:2164 sig1
    fn2 = colocated u16791296:2213 sig2
    fn3 = colocated u16791552:2268 sig3
    fn4 = colocated u16793344:2324 sig4
    fn5 = colocated u16792320:2387 sig5
    fn6 = colocated u16790528:2446 sig6
    fn7 = colocated u16791040:2062 sig7

block0:
    v0 = stack_addr.i64 ss0
    call fn0(v0)
    v1 = stack_addr.i64 ss1
    v2 = stack_addr.i64 ss0
    v3 = load.i64 aligned v2
    v4 = load.i64 aligned v2+8
    v5 = load.i64 aligned v2+16
    store aligned v3, v1
    store aligned v4, v1+8
    store aligned v5, v1+16
    v6 = stack_addr.i64 ss1
    v7 = iconst.i64 0
    call fn1(v6, v7)  ; v7 = 0
    v8 = stack_addr.i64 ss1
    v9 = iconst.i64 1
    call fn1(v8, v9)  ; v9 = 1
    v10 = stack_addr.i64 ss1
    v11 = iconst.i64 2
    call fn1(v10, v11)  ; v11 = 2
    v12 = stack_addr.i64 ss2
    call fn2(v12)
    v13 = stack_addr.i64 ss3
    v14 = stack_addr.i64 ss2
    v15 = load.i64 aligned v14
    v16 = load.i64 aligned v14+8
    v17 = load.i64 aligned v14+16
    store aligned v15, v13
    store aligned v16, v13+8
    store aligned v17, v13+16
    v18 = stack_addr.i64 ss3
    v19 = stack_addr.i64 ss1
    call fn3(v18, v19)
    v20 = stack_addr.i64 ss3
    v21 = iconst.i64 0
    v22 = call fn4(v20, v21)  ; v21 = 0
    v23 = iconst.i64 0
    call fn1(v22, v23)  ; v23 = 0
    v24 = stack_addr.i64 ss3
    v25 = iconst.i64 0
    v26 = call fn5(v24, v25)  ; v25 = 0
    v27 = iconst.i64 3
    v28 = call fn6(v26, v27)  ; v27 = 3
    v29 = stack_addr.i64 ss3
    call fn7(v29)
    v30 = load.i64 v28
    return v30
}
get_ptr function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 v0
    v3 = iconst.i64 8
    v4 = imul v1, v3  ; v3 = 8
    v5 = iadd v2, v4
    return v5
}
get_ptr function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 v0
    v3 = iconst.i64 24
    v4 = imul v1, v3  ; v3 = 24
    v5 = iadd v2, v4
    return v5
}
get_mut_ptr function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 v0
    v3 = iconst.i64 24
    v4 = imul v1, v3  ; v3 = 24
    v5 = iadd v2, v4
    return v5
}
push function u0:0(i64, i64) fast {
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 fast
    sig2 = (i64, i64) fast
    fn0 = colocated u16791552:2991 sig0
    fn1 = colocated u16793344:2324 sig1
    fn2 = colocated u16790272:3047 sig2

block0(v0: i64, v1: i64):
    v2 = load.i64 v0+8
    v3 = load.i64 v0+16
    v4 = icmp eq v2, v3
    brnz v4, block1
    jump block2

block2:
    jump block3

block1:
    call fn0(v0)
    jump block3

block3:
    v5 = load.i64 v0+8
    v6 = call fn1(v0, v5)
    call fn2(v6, v1)
    v7 = iconst.i64 1
    v8 = load.i64 v0+8
    v9 = iadd v8, v7  ; v7 = 1
    store v9, v0+8
    return
}
write function u0:0(i64, i64) fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 aligned v1
    v3 = load.i64 aligned v1+8
    v4 = load.i64 aligned v1+16
    store aligned v2, v0
    store aligned v3, v0+8
    store aligned v4, v0+16
    return
}
grow function u0:0(i64) fast {
    sig0 = (i64, i64) -> i64 fast
    fn0 = u16787456:3160 sig0

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0+16
    v3 = icmp eq v2, v1  ; v1 = 0
    brnz v3, block1
    jump block2

block2:
    v4 = iconst.i64 2
    v5 = load.i64 v0+16
    v6 = imul v5, v4  ; v4 = 2
    jump block3(v6)

block1:
    v7 = iconst.i64 8
    jump block3(v7)  ; v7 = 8

block3(v8: i64):
    store v8, v0+16
    v9 = load.i64 v0
    v10 = iconst.i64 24
    v11 = load.i64 v0+16
    v12 = imul v11, v10  ; v10 = 24
    v13 = call fn0(v9, v12)
    store v13, v0
    return
}
new function u0:0(i64 sret) fast {
block0(v0: i64):
    v1 = iconst.i64 0
    store v1, v0  ; v1 = 0
    v2 = iconst.i64 0
    store v2, v0+8  ; v2 = 0
    v3 = iconst.i64 0
    store v3, v0+16  ; v3 = 0
    return
}
push function u0:0(i64, i64) fast {
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 fast
    sig2 = (i64, i64) fast
    fn0 = colocated u16789760:3262 sig0
    fn1 = colocated u16791552:3311 sig1
    fn2 = colocated u16788480:3367 sig2

block0(v0: i64, v1: i64):
    v2 = load.i64 v0+8
    v3 = load.i64 v0+16
    v4 = icmp eq v2, v3
    brnz v4, block1
    jump block2

block2:
    jump block3

block1:
    call fn0(v0)
    jump block3

block3:
    v5 = load.i64 v0+8
    v6 = call fn1(v0, v5)
    call fn2(v6, v1)
    v7 = iconst.i64 1
    v8 = load.i64 v0+8
    v9 = iadd v8, v7  ; v7 = 1
    store v9, v0+8
    return
}
write function u0:0(i64, i64) fast {
block0(v0: i64, v1: i64):
    store v1, v0
    return
}
get_mut_ptr function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 v0
    v3 = iconst.i64 8
    v4 = imul v1, v3  ; v3 = 8
    v5 = iadd v2, v4
    return v5
}
grow function u0:0(i64) fast {
    sig0 = (i64, i64) -> i64 fast
    fn0 = u16787456:3160 sig0

block0(v0: i64):
    v1 = iconst.i64 0
    v2 = load.i64 v0+16
    v3 = icmp eq v2, v1  ; v1 = 0
    brnz v3, block1
    jump block2

block2:
    v4 = iconst.i64 2
    v5 = load.i64 v0+16
    v6 = imul v5, v4  ; v4 = 2
    jump block3(v6)

block1:
    v7 = iconst.i64 8
    jump block3(v7)  ; v7 = 8

block3(v8: i64):
    store v8, v0+16
    v9 = load.i64 v0
    v10 = iconst.i64 8
    v11 = load.i64 v0+16
    v12 = imul v11, v10  ; v10 = 8
    v13 = call fn0(v9, v12)
    store v13, v0
    return
}
new function u0:0(i64 sret) fast {
block0(v0: i64):
    v1 = iconst.i64 0
    store v1, v0  ; v1 = 0
    v2 = iconst.i64 0
    store v2, v0+8  ; v2 = 0
    v3 = iconst.i64 0
    store v3, v0+16  ; v3 = 0
    return
}
drop function u0:0(i64) fast {
    ss0 = explicit_slot 24
    sig0 = (i64, i64) -> i64 fast
    sig1 = (i64 sret, i64) fast
    sig2 = (i64) fast
    sig3 = (i64) fast
    fn0 = colocated u16792320:2387 sig0
    fn1 = colocated u16790016:3620 sig1
    fn2 = colocated u16789248:3573 sig2
    fn3 = u16786688:3670 sig3

block0(v0: i64):
    v1 = iconst.i64 0
    jump block1(v1)  ; v1 = 0

block1(v2: i64):
    v5 -> v2
    v3 = load.i64 v0+8
    v4 = icmp eq v2, v3
    brnz v4, block2
    jump block3

block3:
    v6 = call fn0(v0, v5)
    v7 = stack_addr.i64 ss0
    call fn1(v7, v6)
    v8 = stack_addr.i64 ss0
    call fn2(v8)
    v9 = iconst.i64 1
    v10 = iadd.i64 v5, v9  ; v9 = 1
    v11 -> v10
    jump block4

block4:
    jump block1(v11)

block2:
    jump block5

block5:
    v12 = load.i64 v0
    call fn3(v12)
    return
}
read function u0:0(i64 sret, i64) fast {
block0(v0: i64, v1: i64):
    v2 = load.i64 aligned v1
    v3 = load.i64 aligned v1+8
    v4 = load.i64 aligned v1+16
    store aligned v2, v0
    store aligned v3, v0+8
    store aligned v4, v0+16
    return
}
drop function u0:0(i64) fast {
    ss0 = explicit_slot 8
    sig0 = (i64, i64) -> i64 fast
    sig1 = (i64) -> i64 fast
    sig2 = (i64) fast
    fn0 = colocated u16790528:2446 sig0
    fn1 = colocated u16788224:3707 sig1
    fn2 = u16786688:3670 sig2

block0(v0: i64):
    v1 = iconst.i64 0
    jump block1(v1)  ; v1 = 0

block1(v2: i64):
    v5 -> v2
    v3 = load.i64 v0+8
    v4 = icmp eq v2, v3
    brnz v4, block2
    jump block3

block3:
    v6 = call fn0(v0, v5)
    v7 = call fn1(v6)
    stack_store v7, ss0
    v8 = stack_addr.i64 ss0
    v9 = iconst.i64 1
    v10 = iadd.i64 v5, v9  ; v9 = 1
    v11 -> v10
    jump block4

block4:
    jump block1(v11)

block2:
    jump block5

block5:
    v12 = load.i64 v0
    call fn2(v12)
    return
}
read function u0:0(i64) -> i64 fast {
block0(v0: i64):
    v1 = load.i64 v0
    return v1
}


info: status: exit status: 0
 = info: stdout: 
 = info: stderr: 

