error: cannot move out of value twice
 --> simple-moves\root.ctl:7:10
  |
7 |     drop(a)
  |          - info: first move here
8 |     drop(a)
  |          ^ double move occurred here
  |

error: cannot move out of value twice
  --> simple-moves\root.ctl:13:14
   |
13 |         drop(a)
   |              - info: first move here
14 |     } 
15 |     drop(a)
   |          ^ double move occurred here
   |

error: cannot move out of value twice
  --> simple-moves\root.ctl:20:14
   |
20 |         drop(a)
   |              - info: first move here
...
23 |     drop(a)
   |          ^ double move occurred here
   |

error: cannot move out of value twice
  --> simple-moves\root.ctl:71:9
   |
71 |         e {
   |         - info: first move here
...
74 |     drop(e)
   |          ^ double move occurred here
   |

info: mir repr of functions:
 fn [] drop(var0: param0) -> ()  {
    block0(var2: param0) {
        return
    }

}

fn [] double_move() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        access var4
        drop[0\A](val4)
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] conditional_double_move() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        var6 = 0
        var7 = 0
        var8 = uint == uint(val6, val7)
        split var8 block1 block2
    }

    block1() {
        access var4
        var5 = drop[0\A](val4)
        goto block3 with var5
    }

    block2() {
        return
    }

    block3(var5: !) {
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] conditional_move() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        var6 = 0
        var7 = 0
        var8 = uint == uint(val6, val7)
        split var8 block1 block2
    }

    block1() {
        access var4
        drop[0\A](val4)
        return
    }

    block2() {
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] reassign() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        access var4
        drop[0\A](val4)
        access var4
        var4 ={}
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] conditional_reassign() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        access var4
        drop[0\A](val4)
        var6 = 0
        var7 = 0
        var8 = uint == uint(val6, val7)
        split var8 block1 block2
    }

    block1() {
        access var4
        var4 ={}
        goto block3 with var4
    }

    block2() {
        access var4
        var4 ={}
        goto block3 with var4
    }

    block3(var5: ()) {
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] conditional_incomplete_reassign() -> ()  {
    block0() {
        var3 ={}
        var4 = var3
        access var4
        drop[0\A](val4)
        var6 = 0
        var7 = 0
        var8 = uint == uint(val6, val7)
        split var8 block1 block2
    }

    block1() {
        access var4
        var4 ={}
        goto block3 with var4
    }

    block2() {
        return
    }

    block3(var5: !) {
        access var4
        var2 = drop[0\A](val4)
        return
    }

}

fn [] enum_move() -> ()  {
    block0() {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var8 = var6.0
        var9 = 0
        var10 = u8 == u8(val8, val9)
        var11 = var6.1
        split var10 block1 block2
    }

    block1() {
        var12 = var6.1
        var13 = var12
        access var13
        var7 = drop[0\A](val13)
        goto block3 with var7
    }

    block2() {
        goto block3
    }

    block3(var7: ()) {
        access var6
        var2 = drop[0\E](val6)
        return
    }

}

fn [] enum_just_match() -> ()  {
    block0() {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var8 = var6.0
        var9 = 0
        var10 = u8 == u8(val8, val9)
        var11 = var6.1
        split var10 block1 block2
    }

    block1() {
        goto block3
    }

    block2() {
        goto block3
    }

    block3(var7: ()) {
        access var6
        var2 = drop[0\E](val6)
        return
    }

}

fn [] enum_whole_move() -> ()  {
    block0() {
        var5 ={var3, var4}
        var3 = 0
        var4 ={}
        var6 = var5
        access var6
        var8 = var6.0
        var9 = 0
        var10 = u8 == u8(val8, val9)
        var11 = var6.1
        split var10 block1 block2
    }

    block1() {
        goto block3
    }

    block2() {
        var12 = var6
        goto block3
    }

    block3(var7: ()) {
        access var6
        var2 = drop[0\E](val6)
        return
    }

}



