use std::{default::default, iter, mem, ops::Index};

use rkyv::{Archive, Deserialize, Serialize};

use crate::{
    field,
    frag_map::{ArcVecInner, FragVec},
    FragMap, FragRef, NoInteriorMutability,
};

use super::ArcVec;

#[derive(Serialize, Deserialize, Archive)]
pub struct ShadowFragMap<T> {
    base: ShadowFragBase<T>,
    local: ShadowFragView<T>,
}

impl<T> ShadowFragMap<T> {
    fn get_low(&self, index: FragRef<T>, backing: &FragMap<T>) -> Option<&T> {
        let thread = self.base.threads.get(index.0.thread as usize)?;
        let backing_thread = backing.others.get(index.0.thread as usize)?;
        assert!(index.0.index as usize <= backing_thread.frozen);
        let len = unsafe { field!(thread.data.0 => len) };
        let border = len.min(backing_thread.frozen);
        unsafe { ArcVecInner::data(thread.data.0, border) }.get(index.0.index as usize)
    }

    pub fn get(&self, index: FragRef<T>, backing: &FragMap<T>) -> &T
    where
        T: NoInteriorMutability,
    {
        self.get_low(index, backing).unwrap_or(&self.base.default)
    }

    pub fn get_mut(&mut self, index: FragRef<T>, backing: &FragMap<T>) -> &mut T
    where
        T: Default,
    {
        let thread = &mut self.base.threads[index.0.thread as usize];
        let backing_thread = &backing.others[index.0.thread as usize];
        assert!(index.0.index as usize > backing_thread.frozen);
        let len = unsafe { field!(thread.data.0 => len) };

        thread
            .data
            .extend((len..index.0.index as usize).map(|_| default()));
        unsafe { &mut *ArcVecInner::get_item(thread.data.0, index.0.index as usize) }
    }
}

#[derive(Serialize, Deserialize, Archive)]
pub struct ShadowFragBase<T> {
    threads: Box<[ShadowFragView<T>]>,
    default: T,
}

impl<T> ShadowFragBase<T> {
    pub fn new(thread_count: u8) -> Self
    where
        T: Default,
    {
        Self {
            threads: iter::repeat_with(ShadowFragView::new)
                .take(thread_count as usize)
                .collect(),
            default: default(),
        }
    }

    pub fn expand(&mut self, thread_count: u8) {
        let threads = (self.threads.len() as u8..thread_count).map(|_| ShadowFragView::new());
        let current = mem::take(&mut self.threads);
        self.threads = current.into_vec().into_iter().chain(threads).collect();
    }

    pub fn split(&self) -> 
}

#[derive(Serialize, Deserialize, Archive)]
pub struct ShadowFragView<T> {
    data: ArcVec<T>,
}

impl<T> ShadowFragView<T> {
    fn new() -> Self {
        Self {
            data: ArcVec::new(),
        }
    }
}
