use {
    "root/structs"
    "root/generics"
    "root/patterns"
}

#macro(source, source)
fn hello() {
    putchar('g')
    putchar('g')
}

#entry
fn main() -> int {
    if other(1, 2, 3) != 7 {
        return 1
    }

    if structs::bti(true) != 1 {
        return 2
    }

    if generics::bti(false) != 0 {
        return 3
    }

    if fib(5) != 8 {
        return 4
    }

    if iter_fib(5) != 8 {
        return 5
    }

    {
        let mut i = 1
        let mut b = 0
        if loop { if i > 100 {
            break b
        } else {
            b += i
            i += 1
        } } != 5050 {
            return 6
        }
    }

    if structure_test() != 0 {
        return structure_test()
        return 7
    }

    if init_something().a != 0 {
        return 8
    }

    if move_in_and_out(0) != 0 {
        return 9
    }

    if Goo::new().field() != 10 {
        return 10
    }

    // stress test
    if (*PtrTest::{ a: false; b: false; c: true }.as_ptr()).c {} else {
        return 11
    }

    if foo::[Goo]() + foo::[Goo]() != 20 {
        return 12
    }

    if Loo::{ field: Loo::{ field: 90; yes: false }.as_ptr(); yes: true }.field.field != 90 {
        return 13
    }

    let vec = Vec::new::[int]()

    let ptr = malloc(100)

    if ptr as int == 0 {
        return 15
    }

    putchar('a')

    if Enum::Something::{}.is_something() {} else {
        return 16
    }

    putchar('b')

    if Enum::Structural::{ integer: 6 }.integer() != 6 {
        putchar('f')
        return 17
    }

    putchar('h')
    exit(-34)

    0
}

impl Loo {
    fn [T] as_ptr(s: *Loo[T]) -> *Loo[T] {
        s
    }
}

struct PtrTest {
    a: bool
    b: bool
    c: bool
}

impl PtrTest {
    fn as_ptr(s: *Self) -> *Self {
        s
    }

    fn as_ptr_ptr(s: * *Self) -> * *Self {
        s
    }
}

fn fib(x: int) -> int {
    if x < 2 {
        1
    } else {
        fib(x - 1) + fib(x - 2)
    }
}

fn iter_fib(x: int) -> int {
    let mut i = 1
    let mut a = 1
    let mut b = 1
    
    loop {
        if i >= x {
            break b
        }

        let c = a + b
        a = b
        b = c

        i += 1
    }
}

fn "default" exit(code: int) extern
