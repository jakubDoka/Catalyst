

fn "default" putchar(char: char) -> char extern
fn "default" malloc(size: int) -> ^mut u8 extern
fn "default" free(ptr: ^mut u8) extern
fn "default" realloc(ptr: ^mut u8, size: uint) -> ^mut u8 extern
fn "default" exit(code: int) extern

impl uint {
    fn max(a: Self, b: Self) -> Self {
        if a < b { b } else { a }
    }
}

impl uint {
    fn log(s: Self) {
        let mut div = 10u
        loop {
            if s < div {
                break
            }
            div *= 10u
        }

        loop {
            div /= 10u
            if div == 0u {
                break
            }
            let s = s / div
            putchar(('0' as u32 + s.u32() % 10u32) as char)
        }
    }
}

impl str {
    fn log(s: ^Self) {
        let mut i = 0u
        loop {
            if i >= s.len {
                break
            }
            putchar(((s.ptr as uint + i) as ^u8).u32() as char)
            i += 1u
        }
    }
}

#no_ownership
fn [T] unsafe_read(value: ^T) -> T {
    *value
}

#no_ownership
fn [T] unsafe_write(value: ^mut T, new_value: T) {
    *value = new_value
}

struct [T] Vec {
    data: ^mut T
    len: uint
    cap: uint
}

/*
fn [T] zeroed() -> T {
    [0u8; size_of::[T]()] as T
}
*/

impl Vec {
    fn [T] new() -> Self[T] {
        Self::{
            data: 0 as ^mut T
            len: 0u
            cap: 0u
        }
    }

    fn [T] push(s: ^mut Self[T], elem: T) {
        s.len += 1u

        if s.len >= s.cap {
            let new_cap = s.cap.max(1u) * 2u
            let cap_in_bytes = new_cap * size_of::[T]()
            s.data = realloc(s.data as ^mut u8, cap_in_bytes) as ^mut T
            s.cap = new_cap
        }

        unsafe_write(s.get_unwrapped_last(), elem)
    }

    fn [T] drop_range(s: ^mut Self[T], start: uint, end: uint) {
        let mut i = start
        loop {
            if i >= end {
                break
            }
            s.drop_elem(i)
            i += 1u     
        }
    }

    fn [T] drop_elem(s: ^mut Self[T], index: uint) {
        let elem = s.get_unwrapped_mut(index)
        unsafe_read(elem)
    }

    fn [T] get_unwrapped_mut(s: ^mut Self[T], index: uint) -> ^mut T {
        (s.data as uint + index * size_of::[T]()) as ^mut T
    }

    fn [T] get_unwrapped_last(s: ^mut Self[T]) -> ^mut T {
        s.get_unwrapped_mut(s.len - 1u)
    }
}

impl [T] drop as Vec[T] {
    fn drop(s: ^mut Self) {
        s.drop_range(0u, s.len)
        free(s.data as ^mut u8)
    }
}
