fn other(a: int, b: int, c: int) -> int {
    return a + b * c
}

fn bti(b: bool) -> int {
    return if b { 1 } else { 0 }
}

fn structure_test() -> int {
    let mut something = init_something()
    something = Something::{
        a: 2
        b {
            e: true
            f: false
        }
        e: true
    }

    let something_else = init_something_else()

    if something.e {} else {
        return -1
    }

    something.a - bti(something.b.e) + -bti(something_else.f)
}

fn init_something_else() -> SomethingElse {
    SomethingElse::{ e: false; f: true }
}

fn init_something() -> Something {
    Something::{
        a: 0
        b {
            e: false
            f: false           
        }
        e: false
    }
}

struct Something {
    a: int
    b: SomethingElse
    e: bool
}

struct SomethingElse {
    e: bool
    f: bool
}

// bh
/*
    /*

    */
*/

/*
    bound Bound {
        fn operation() extern
        fn something_with_int(i: int) extern
        fn return_stuff(s: Self) -> bool extern

        fn default_member(s: Self) -> int {
            Self::operation()
            Self::something_with_int(42) * bti(s.return_stuff())
        }
    }
*/