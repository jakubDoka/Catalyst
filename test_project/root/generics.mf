
fn [T] move_in_and_out(arg: T) -> T {
    arg
}

struct [T] Loo {
    field: T
    yes: bool
}

struct Goo {
    afield: int
}

impl Goo {
    fn new() -> Self {
        Self::{
            afield: 10
        }
    }

    fn field(s: ^Self) -> int {
        s.afield
    }

    fn something() {}
}

impl Spec as Goo {
    use something as try

    fn and_this() {
        putchar('u')
    }
}


fn bti(b: bool) -> int {
    return if b { 1 } else { 0 }
}

fn [T: Spec] foo() -> int {
    T::try()
    T::and_this()
    T::new().field()
}

bound Spec {
    fn new() -> Self
    fn field(s: ^Self) -> int
    fn try()
    fn and_this()
}

fn "default" putchar(char: char) -> char extern

fn "default" malloc(size: int) -> ^i8 extern

struct [T] Vec {
    data: ^T
    len: int
    cap: int
}

impl Vec {
    fn [T] new() -> Self[T] {
        Self::{
            data: 0 as ^T
            len: 0
            cap: 0
        }
    }
}