
fn [T] move_in_and_out(arg: T) -> T {
    arg
}

struct Goo {
    field: int
}

impl Goo {
    fn new() -> Self {
        Self::{
            field: 10
        }
    }

    fn field(s: *Self) -> int {
        s.field
    }

    fn something() {}
}

impl Spec as Goo {
    use something as try

    fn and_this() {}
}


fn bti(b: bool) -> int {
    return if b { 1 } else { 0 }
}

fn [T: Spec] foo() -> int {
    T::new().field() + T::twenty()
}

bound Spec {
    fn new() -> Self
    fn field(s: *Self) -> int
    fn try()
    fn and_this()
}

impl Spec {
    fn twenty() -> int {
        20
    }
}